package com.zealocity;

import java.io.UnsupportedEncodingException;
import java.lang.reflect.Method;
import java.util.UUID;

import android.app.Activity;
import android.content.Context;
import android.content.SharedPreferences;
import android.provider.Settings.Secure;
import android.telephony.TelephonyManager;
import android.util.Log;
import android.widget.Toast;

public class baseActivity extends Activity {

    private static final String LOG_TAG = "baseActivity"; // Tag used to prefix all log messages
    public static final String PREFS_NAME = "basePreferences";
    protected static UUID uuid;

	public void logMessage(String Message){
		logMessage(LOG_TAG, Message);
	}

	public void logMessage(String LogTag, String Message){
		Log.e(LogTag, "logMessage: " + Message);
		
		// comment this for production
		//showgMessage(Message);
	}
	
	public void showgMessage(String Message){
		if(Message.trim().length() > 0){
			Toast.makeText(this, Message, Toast.LENGTH_SHORT).show();
		}
	}

	public String getSettings(String key){
        SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
        String restoredText = settings.getString(key, "");
        
        logMessage("getSettings: " + key + " - " + restoredText);
        
        return restoredText;
    }
    
	public void saveSettings(String key, String value){
    	SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
        SharedPreferences.Editor editor = settings.edit();
        editor.putString(key, value);
        editor.commit();
        
        logMessage("saveSettings: " + key + " - " + value);
    }
    

	    /**
	     * Returns a unique UUID for the current android device.  As with all UUIDs, this unique ID is "very highly likely"
	     * to be unique across all Android devices.  Much more so than ANDROID_ID is.
	     *
	     * The UUID is generated by using ANDROID_ID as the base key if appropriate, falling back on
	     * TelephonyManager.getDeviceID() if ANDROID_ID is known to be incorrect, and finally falling back
	     * on a random UUID that's persisted to SharedPreferences if getDeviceID() does not return a
	     * usable value.
	     *
	     * In some rare circumstances, this ID may change.  In particular, if the device is factory reset a new device ID
	     * may be generated.  In addition, if a user upgrades their phone from certain buggy implementations of Android 2.2
	     * to a newer, non-buggy version of Android, the device ID may change.  Or, if a user uninstalls your app on
	     * a device that has neither a proper Android ID nor a Device ID, this ID may change on reinstallation.
	     *
	     * Note that if the code falls back on using TelephonyManager.getDeviceId(), the resulting ID will NOT
	     * change after a factory reset.  Something to be aware of.
	     *
	     * Works around a bug in Android 2.2 for many devices when using ANDROID_ID directly.
	     *
	     * @see http://code.google.com/p/android/issues/detail?id=10603
	     *
	     * @return a UUID that may be used to uniquely identify your device for most purposes.
	     */
		// http://www.pocketmagic.net/?p=1662
		// http://innovator.samsungmobile.com/cms/cnts/knowledge.detail.view.do?platformId=1&cntsId=9640
		// http://stackoverflow.com/questions/2785485/is-there-a-unique-android-device-id
	    public UUID getDeviceUuid() {
	        if( uuid ==null ) {
	            synchronized (baseActivity.class) {
	                if( uuid == null) {
	                	String serialId = "";
	                	String deviceId = "";
	                	String androidId = "";
	                	
	                	try {
	                		androidId = Secure.getString(super.getContentResolver(), Secure.ANDROID_ID);
	                	}
	                	catch(Exception ignored) {
	                	}
	                	
	                    // Use the Android ID unless it's broken, in which case fallback on deviceId,
	                    // unless it's not available, then fallback on a random number 
	                    try {
	                    	if (!"9774d56d682e549c".equals(androidId)) {
	                    		uuid = UUID.nameUUIDFromBytes(androidId.getBytes("utf8"));
	                        } else {
	                        	final TelephonyManager tm = (TelephonyManager) getBaseContext().getSystemService(Context.TELEPHONY_SERVICE);
	                        	
	                            deviceId = tm.getDeviceId();
	                            //uuid = deviceId!=null ? UUID.nameUUIDFromBytes(deviceId.getBytes("utf8")) : UUID.randomUUID();

	                            serialId = tm.getSimSerialNumber();
	                        }
	                    } catch (UnsupportedEncodingException e) {
	                        //throw new RuntimeException(e);
	                    } catch (Exception ignored) {                               
	                    }
	                    
	                    if (serialId == "" || serialId == null)      
	                    {                                                                                                                      
		                    try {                                                                               
		                    	Class<?> c = Class.forName("android.os.SystemProperties");        	 
		                    	Method get = c.getMethod("get", String.class, String.class );                     
		                    	serialId = (String)( get.invoke(c, "ro.serialno", "" ) );              
		                    }                                                                                 
		                    catch (Exception ignored)                                                         
		                    {                               
		                    }
	                    }
	                    
	                    if (deviceId == null) {
	                    	deviceId = "";
	                    }
	                    if (serialId == null) {
	                    	serialId = "";
	                    }
	                    
                        uuid = new UUID(androidId.hashCode(), ((long)deviceId.hashCode() << 32) | serialId.hashCode());
	                }
	            }
	        }
	        
	        return uuid;
	    }	
	    
}
